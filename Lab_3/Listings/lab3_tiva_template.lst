


ARM Macro Assembler    Page 1 


    1 00000000         ; This code is based upon InputOutput's from the book:
    2 00000000         ;  "Embedded Systems: Introduction to ARM Cortex M Micro
                       controllers"
    3 00000000         ;  ISBN: 978-1469998749, Jonathan Valvano, copyright (c)
                        2014
    4 00000000         ;
    5 00000000         ; The code provided initializes all 3 ports (A,B,E) with
                        the ECE Shield plugged into the Tiva board
    6 00000000         ; Port F with the Tiva 3 LEDs (Red, Green, Blue) and two
                        buttons is also initialized
    7 00000000         ; Then the LEDs on each port are turned off and on with 
                       time delays - while the Tiva board R, G, B LEDs are turn
                       ed on and off
    8 00000000         ;
    9 00000000         ; Dec 2017
   10 00000000         
   11 00000000                 AREA             |.text|, CODE, READONLY, ALIGN=
2
   12 00000000                 THUMB
   13 00000000                 EXPORT           Start
   14 00000000         
   15 00000000         ; These equates allow one to associate a name with a val
                       ue to make the code more readable
   16 00000000         
   17 00000000 00000002 
                       RED     EQU              0x02        ; These are the val
                                                            ues (bit locations)
                                                             for various LEDs o
                                                            n the Tiva (Port F)
                                                            
   18 00000000 00000004 
                       BLUE    EQU              0x04
   19 00000000 00000008 
                       GREEN   EQU              0x08
   20 00000000 00000010 
                       SW1     EQU              0x10        ; on the left side 
                                                            of the Tiva board
   21 00000000 00000001 
                       SW2     EQU              0x01        ; on the right side
                                                             of the Tiva board
   22 00000000         
   23 00000000         Start
   24 00000000 F000 F87F       BL               Port_Init   ; initialize input 
                                                            and output pins of 
                                                            Ports A to F
   25 00000004 4C7E            LDR              R4, =GPIO_PORTF_DATA_R ; pointe
                                                            r to Port F data re
                                                            gister
   26 00000006         
   27 00000006         ; each of the Tiva ports is 8 bits wide and connect to w
                       ires which can be inputs or outputs
   28 00000006         
   29 00000006         ; to read the buttons on port F use the address GPIO_POR
                       TF_DATA_R
   30 00000006         
   31 00000006         ; Simple turning on and off of LEDs
   32 00000006         ; by default (0 is the default output) all 8 LEDs are of
                       f (active high) while all 7-segment digits are on (activ
                       e low)



ARM Macro Assembler    Page 2 


   33 00000006         
   34 00000006         ; turn off 7 port B LEDs on the shielf - the last LED is
                        on Port E
   35 00000006 4B7F            LDR              R3, =GPIO_PORTB + (PORT_B_MASK 
<< 2) 
                                                            ; generate the base
                                                             address for port B
                                                            
   36 00000008 F04F 0100       MOV              R1, #0      ; write out a 0 to 
                                                            turn off the 7 LEDs
                                                             on port B
   37 0000000C 6019            STR              R1, [R3, #GPIO_DATA_OFFSET] ; G
                                                            PIO_DATA_OFFSET is 
                                                            the address offset 
                                                            to get to the DATA 
                                                            part of the port
   38 0000000E         
   39 0000000E         ; The last LED is on port E - so read the value, modify 
                       bit 1 as it drives the LED and write it back out - this 
                       is called read-modify-write
   40 0000000E 4B8A            LDR              R3, =GPIO_PORTE + (PORT_E_MASK 
<< 2) 
                                                            ; generate the base
                                                             address for port E
                                                            
   41 00000010 6819            LDR              R1, [R3, #GPIO_DATA_OFFSET] ; G
                                                            PIO_DATA_OFFSET is 
                                                            the address offset 
                                                            to get to the DATA 
                                                            part of the port
   42 00000012 F001 01FD       AND              R1, #0xFD   ; set E1 0 to turn 
                                                            that LED off
   43 00000016 6019            STR              R1, [R3, #GPIO_DATA_OFFSET] ; w
                                                            rite the data back 
                                                            out
   44 00000018         
   45 00000018 F24F 3BC0       MOV              R11, #0xf3c0 ; initialize the R
                                                            andom Number routin
                                                            e - NEVER WRITE TO 
                                                            R11 AFTER THIS
   46 0000001C F000 F851       BL               RandomNum   ; ADDED - Branch to
                                                             RandomNum to gener
                                                            ate a number to mul
                                                            tiply the 0.1ms del
                                                            ay by
   47 00000020 4659            MOV              R1, R11     ; ADDED - Store the
                                                             random number in R
                                                            1 to multiply the d
                                                            elay by in order to
                                                             generate a random 
                                                            delay
   48 00000022 F000 F83C       BL               RandomMap   ; Added 
   49 00000026 F000 F82F       BL               ShortDelay  ; ADDED - We need t
                                                            o branch to the del
                                                            ay
   50 0000002A         
   51 0000002A         ; Turn on a LED after the delay and initialize a counter
                       . 
   52 0000002A         ; The value of this counter will later be displayed afte



ARM Macro Assembler    Page 3 


                       r the user has pushed the button
   53 0000002A         
   54 0000002A         ; The last LED is on port E - so read the value, modify 
                       the B1 (bit 1) as it drives an LED and write it back out
                        - this is called read-modify-write
   55 0000002A 4B83            LDR              R3, =GPIO_PORTE + (PORT_E_MASK 
<< 2) 
                                                            ; generate the base
                                                             address for port B
                                                            
   56 0000002C 6819            LDR              R1, [R3, #GPIO_DATA_OFFSET] ; G
                                                            PIO_DATA_OFFSET is 
                                                            the address offset 
                                                            to get to the DATA 
                                                            part of the port
   57 0000002E F001 01FD       AND              R1, #0xFD   ; preserve everythi
                                                            ng but B1 while B1 
                                                            gets set to 0
   58 00000032 F041 0102       ORR              R1, #0x02   ; set B1 - these tw
                                                            o lines could be re
                                                            placed with a singl
                                                            e ORR statement
   59 00000036 6019            STR              R1, [R3, #GPIO_DATA_OFFSET] ; w
                                                            rite the data back 
                                                            out
   60 00000038         
   61 00000038         ; Initialize a counter
   62 00000038 F04F 0500       MOV              R5, #0      ;Initialize a count
                                                            er to measure the t
                                                            ime taken for the r
                                                            eflex meter
   63 0000003C F04F 0101       MOV              R1 , #1     ;Only one delay loo
                                                            p each time
   64 00000040 F000 F813       BL               POLLING_LOOP
   65 00000044         
   66 00000044         Bitshift
   67 00000044 F644 6120       MOV              R1, #0x4E20
   68 00000048 F04F 04FF       MOV              R4, #0xFF
   69 0000004C EA04 0405       AND              R4,R5
   70 00000050 EA4F 2515       LSR              R5,#8
   71 00000054 F000 F82A       BL               Display
   72 00000058 F000 F816       BL               Delay
   73 0000005C 2D00            CMP              R5, #0
   74 0000005E D1F1            BNE              Bitshift
   75 00000060         
   76 00000060 F24C 3150       MOV              R1, #0xC350 ;5 second delay
   77 00000064 F000 F810       BL               Delay       ;
   78 00000068 E7FE            B                Start       ;
   79 0000006A         
   80 0000006A         POLLING_LOOP
   81 0000006A B519            STMFD            R13!,{R0, R3, R4, R14} ; pull t
                                                            he LR or return add
                                                            ress and return
   82 0000006C         
   83 0000006C         POLLING
   84 0000006C F000 F80C       BL               ShortDelay  ; ShortDelay subrou
                                                            tine - delay for a 
                                                            fixed amount of tim
                                                            e. Go for a 0.1ms d



ARM Macro Assembler    Page 4 


                                                            elay loop
   85 00000070 F105 0501       ADD              R5, R5, #1  ;increment polling 
                                                            counter
   86 00000074         
   87 00000074 F04F 0310       MOV              R3, #SW1
   88 00000078 4C61            LDR              R4, =GPIO_PORTF_DATA_R ; pointe
                                                            r to Port F data re
                                                            gister
   89 0000007A 6820            LDR              R0, [R4, #GPIO_DATA_OFFSET] ;st
                                                            ore the contents of
                                                             R4 plus the DATA_O
                                                            FFSET into R0 in or
                                                            der to register a p
                                                            ush button         
                                                                
   90 0000007C         
   91 0000007C EA03 0300       AND              R3, R0      ; Reads switch
   92 00000080 2B00            CMP              R3, #0      ; Compare R3 with z
                                                            ero to check if a b
                                                            utton was pushed (c
                                                            ompare with 0 as a 
                                                            0 is used for butto
                                                            n push)
   93 00000082 D0DF            BEQ              Bitshift    ; Shift the bits us
                                                            ing the BitShift lo
                                                            op if the CMP R3, #
                                                            0 was equal to 0
   94 00000084 D1F2            BNE              POLLING     ; Otherwise, if not
                                                             equal to 0, keep o
                                                            n polling
   95 00000086 BD19            LDMFD            R13!,{R0,R3,R4, R15} ; pull the
                                                             LR or return addre
                                                            ss and return
   96 00000088         
   97 00000088         ; 
   98 00000088         ;
   99 00000088         ; What do we need to do then?
  100 00000088         ; Write code for a subroutine which implements a 0.1 mil
                       lisecond delay.
  101 00000088         ; I'm guessing you can implement this from Lab1
  102 00000088         ; How I got the fraction of a second delay? Delay of 500
                       ms was 2750000 -> 1ms = 5500 -> 0.1ms = 550
  103 00000088         ;
  104 00000088         ; To confirm the duration of 0.1 millisecond, you can do
                        the following steps:
  105 00000088         ; a) Turn one LED on
  106 00000088         ; b) Call the subroutine in a loop for 100000 times (#10
                       0000 or #0x186A0)
  107 00000088         ; c) Turn the LED off
  108 00000088         ; d) Run the code and measure the time that the LED stay
                       s on. It must be for 100000x0.1 millisecond = 10 seconds
                       
  109 00000088         ; *END*
  110 00000088         ;
  111 00000088         ; Input: R1 - how many times do we loop (multiply) the f
                       ixed delay - If R1 = 0 then there is no time delay
  112 00000088         ; At this point, R1 = #1000
  113 00000088         ; Output: none
  114 00000088         ;



ARM Macro Assembler    Page 5 


  115 00000088         ; Need to check the value of R1. This controls how much 
                       times we multiply the fixed delay. 
  116 00000088         ; Delay 0.1ms (100us) * R1 times
  117 00000088         
  118 00000088 00000226 
                       SHORTDELAYCOUNT
                               EQU              550         ; fraction of a sec
                                                            ond delay
  119 00000088         ; This number was changed from 400 to 550
  120 00000088         
  121 00000088         Delay                                ; alternate name fo
                                                            r this subroutine
  122 00000088         ShortDelay
  123 00000088 B503            STMFD            R13!,{R0, R1, R14} ; push the L
                                                            R or return address
                                                            
  124 0000008A         
  125 0000008A         delay_outer_loop
  126 0000008A F091 0F00       TEQ              R1, #0      ; Check if R1 is eq
                                                            ual to 0
  127 0000008E F240 2026       LDR              R0, =SHORTDELAYCOUNT ; Load the
                                                             value of shortdela
                                                            ycount into R0
  128 00000092         
  129 00000092         delay_loop
  130 00000092 1E40            SUBS             R0, R0, #1  ; R0 = R0 - 1 (coun
                                                            t = count - 1) and 
                                                            set N, Z, C status 
                                                            bits
  131 00000094 D1FD            BNE              delay_loop  ; If the counter R0
                                                             is not 0, return b
                                                            ack to the delay lo
                                                            op
  132 00000096 1E49            SUBS             R1, R1, #1  ; Decrement loop co
                                                            unter
  133 00000098 D000            BEQ              exitDelay   ; If R1 is 0, don't
                                                             loop again
  134 0000009A D1F6            BNE              delay_outer_loop ; If R1 is not
                                                             0, loop again
  135 0000009C         
  136 0000009C         exitDelay
  137 0000009C BD03            LDMFD            R13!,{R0, R1, R15} ; pull the L
                                                            R or return address
                                                             and return
  138 0000009E         
  139 0000009E         RandomMap                            ;This function is u
                                                            sed to produce a nu
                                                            mber within 2 and 1
                                                            0
  140 0000009E 00004E20 
                       CONSTANT
                               EQU              20000       ; 
  141 0000009E B501            STMFD            R13!,{R0, R14} ; push the LR or
                                                             return address
  142 000000A0 EA4F 01D1       LSR              R1, R1 , #3 ; divide by 8
  143 000000A4 F644 6020       LDR              R0,=CONSTANT
  144 000000A8 4401            ADD              R1, R1, R0  ; add 160000 to map
                                                             in range
  145 000000AA BD01            LDMFD            R13!,{R0, R15} ; pull the LR or



ARM Macro Assembler    Page 6 


                                                             return address and
                                                             return
  146 000000AC         
  147 000000AC         Display
  148 000000AC B503            STMFD            R13!,{R0, R1,R14} ;
  149 000000AE         Displayloop
  150 000000AE         ;MOV        R0,#0xFF
  151 000000AE         ;AND        R0, R5  ; Read a (byte) character to convert
                        to a Morse pattern
  152 000000AE         ;turn on  port B LEDs on the shielf - the last LED is on
                        Port E
  153 000000AE 4B55            LDR              R3, =GPIO_PORTB + (PORT_B_MASK 
<< 2) 
                                                            ; generate the base
                                                             address for port B
                                                            
  154 000000B0 601C            STR              R4, [R3, #GPIO_DATA_OFFSET] ; G
                                                            PIO_DATA_OFFSET is 
                                                            the address offset 
                                                            to get to the DATA 
                                                            part of the port
  155 000000B2         
  156 000000B2         ; The last LED is on port E - so read the value, modify 
                       bit 1 as it drives the LED and write it back out - this 
                       is called read-modify-write
  157 000000B2 4B61            LDR              R3, =GPIO_PORTE + (PORT_E_MASK 
<< 2) 
                                                            ; generate the base
                                                             address for port E
                                                            
  158 000000B4 6819            LDR              R1, [R3, #GPIO_DATA_OFFSET] ; G
                                                            PIO_DATA_OFFSET is 
                                                            the address offset 
                                                            to get to the DATA 
                                                            part of the port
  159 000000B6 F001 01FD       AND              R1, #0xFD   ; set E1 0 to turn 
                                                            that LED off
  160 000000BA EA41 0104       ORR              R1, R4      ; set B1 - these tw
                                                            o lines could be re
                                                            placed with a singl
                                                            e ORR statement
  161 000000BE 6019            STR              R1, [R3, #GPIO_DATA_OFFSET] ; w
                                                            rite the data back 
                                                            out
  162 000000C0         
  163 000000C0 BD03            LDMFD            R13!,{R0,R1, R15} ; pull the LR
                                                             or return address 
                                                            and return
  164 000000C2         
  165 000000C2         
  166 000000C2         ;1-If a 32-bit register is counting user reaction time i
                       n 0.1 milliseconds increments, what is the maximum amoun
                       t of time which can be stored in 8 bits, 16-bits, 24-bit
                       s and 32-bits?
  167 000000C2         ; 8 bits - 255 * 0.1ms = 25.5 ms = 0.0255 s
  168 000000C2         ;16-bits - 65535 * 0.1ms = 6553.5ms = 6.5535 s, 
  169 000000C2         ;24-bits -16777215 * 0.1ms = 1677721.5 ms = 1677.7215s
  170 000000C2         ;32-bits-4294967295* 0.1ms = 429496729.5 ms = 429496.729
                       5 s



ARM Macro Assembler    Page 7 


  171 000000C2         
  172 000000C2         ;2-Considering typical human reaction time, which size w
                       ould be the best for this task (8, 16, 24, or 32 bits)? 
                       
  173 000000C2         ; The typical human reaction time is 0.25 s which would 
                       make the 16 bit the best size for the task
  174 000000C2         
  175 000000C2         ; * * * * * * * * * * * * * * * * * * * * * * * * * * * 
                       * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
                       * * * * * * * * * 
  176 000000C2         ;   DO NOT EDIT CODE BELOW THIS LINE
  177 000000C2         ; * * * * * * * * * * * * * * * * * * * * * * * * * * * 
                       * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
                       * * * * * * * * * 
  178 000000C2         
  179 000000C2         ;------------RandomNum------------
  180 000000C2         ; R11 holds a 16-bit "random" number via a pseudo-random
                        sequence as per the Linear feedback shift register (Fib
                       onacci) on WikiPedia
  181 000000C2         ; Take as many bits of R11 as you need.
  182 000000C2         ;
  183 000000C2         ; R11 can be read anywhere in the user code but must onl
                       y be written to by this subroutine
  184 000000C2         ;
  185 000000C2         ; INPUT: R11 - before calling this for the FIRST time R1
                       1 must be initialized to a large 16-bit non-zero value
  186 000000C2         ;      if R11 is ever set to 0 then R11 will stay stuck 
                       at zero
  187 000000C2         ; OUTPUT: R11 - random number is the lowest 16 bits of R
                       11 which is between 1 and 0xffff
  188 000000C2         ;
  189 000000C2 B50E    RandomNum
                               STMFD            R13!,{R1, R2, R3, R14}
  190 000000C4         
  191 000000C4 F40B 4100       AND              R1, R11, #0x8000
  192 000000C8 F40B 5200       AND              R2, R11, #0x2000
  193 000000CC EA4F 0282       LSL              R2, #2
  194 000000D0 EA81 0302       EOR              R3, R1, R2
  195 000000D4 F40B 5180       AND              R1, R11, #0x1000
  196 000000D8 EA4F 01C1       LSL              R1, #3
  197 000000DC EA83 0301       EOR              R3, R3, R1
  198 000000E0 F40B 6180       AND              R1, R11, #0x0400
  199 000000E4 EA4F 1141       LSL              R1, #5
  200 000000E8 EA83 0301       EOR              R3, R3, R1  ; the new bit to go
                                                             into the LSB is pr
                                                            esent
  201 000000EC EA4F 33D3       LSR              R3, #15
  202 000000F0 EA4F 0B4B       LSL              R11, #1
  203 000000F4 EA4B 0B03       ORR              R11, R11, R3
  204 000000F8 F64F 71FF       MOV              R1, #0xFFFF
  205 000000FC EA0B 0B01       AND              R11, R1     ; clear the upper 1
                                                            6 bits of R11 as th
                                                            ey're not part of t
                                                            he random #
  206 00000100         
  207 00000100 BD0E            LDMFD            R13!,{R1, R2, R3, R15}
  208 00000102         
  209 00000102         
  210 00000102         ; Tons of initialization to be done in order to use the 



ARM Macro Assembler    Page 8 


                       I/O ports as they're off by default.
  211 00000102         ;
  212 00000102         ; Define the addresses and provide functions to initiali
                       ze everything.
  213 00000102         
  214 00000102 40025400 
                       GPIO_PORTF_DIR_R
                               EQU              0x40025400  ; Port F Data Direc
                                                            tion Register setti
                                                            ng pins as input or
                                                             output
  215 00000102 400253FC 
                       GPIO_PORTF_DATA_R
                               EQU              0x400253FC  ; address for readi
                                                            ng button inputs an
                                                            d writing to LEDs
  216 00000102 40025420 
                       GPIO_PORTF_AFSEL_R
                               EQU              0x40025420
  217 00000102 40025510 
                       GPIO_PORTF_PUR_R
                               EQU              0x40025510
  218 00000102 4002551C 
                       GPIO_PORTF_DEN_R
                               EQU              0x4002551C
  219 00000102 40025520 
                       GPIO_PORTF_LOCK_R
                               EQU              0x40025520
  220 00000102 40025524 
                       GPIO_PORTF_CR_R
                               EQU              0x40025524
  221 00000102 40025528 
                       GPIO_PORTF_AMSEL_R
                               EQU              0x40025528
  222 00000102 4002552C 
                       GPIO_PORTF_PCTL_R
                               EQU              0x4002552C
  223 00000102         
  224 00000102         ;Section 3.1.2 Nested Vector Interrupt Controller
  225 00000102         
  226 00000102         ;The Cortex-M4F processor supports interrupts and system
                        exceptions. The processor and the
  227 00000102         ;Nested Vectored Interrupt Controller (NVIC) prioritize 
                       and handle all exceptions. An exception
  228 00000102         ;changes the normal flow of software control. The proces
                       sor uses Handler mode to handle all
  229 00000102         ;exceptions except for reset. See “Exception Entry and R
                       eturn” on page 108 for more information.
  230 00000102         ;The NVIC registers control interrupt handling. See “Nes
                       ted Vectored Interrupt Controller
  231 00000102         ;(NVIC)” on page 124 for more information.
  232 00000102         
  233 00000102         ;Table 3-8 on page 134 details interrupt Set / Clear 
  234 00000102         ; they allow one to enable individual interrupts and DIS
                       ? lets one disable individual interrupt numbers
  235 00000102         
  236 00000102         ; Table 2-9 Interrupts on page 104 details interrupt num
                       ber / bit assignments
  237 00000102         ; Port F - Bit 30



ARM Macro Assembler    Page 9 


  238 00000102         ; Timer 0A Bit 19
  239 00000102         ; Timer 0B Bit 20
  240 00000102         
  241 00000102         ;For edge-triggered interrupts, software must clear the 
                       interrupt to enable any further interrupts.
  242 00000102         
  243 00000102         ; NOTE: The NMI (non-maskable interrupt) is on PF0.  Tha
                       t means that
  244 00000102         ; the Alternate Function Select, Pull-Up Resistor, Pull-
                       Down Resistor,
  245 00000102         ; and Digital Enable are all locked for PF0 until a valu
                       e of 0x4C4F434B
  246 00000102         ; is written to the Port F GPIO Lock Register.  After Po
                       rt F is
  247 00000102         ; unlocked, bit 0 of the Port F GPIO Commit Register mus
                       t be set to
  248 00000102         ; allow access to PF0's control registers.  On the LM4F1
                       20, the other
  249 00000102         ; bits of the Port F GPIO Commit Register are hard-wired
                        to 1, meaning
  250 00000102         ; that the rest of Port F can always be freely re-config
                       ured at any
  251 00000102         ; time.  Requiring this procedure makes it unlikely to a
                       ccidentally
  252 00000102         ; re-configure the JTAG and NMI pins as GPIO, which can 
                       lock the
  253 00000102         ; debugger out of the processor and make it permanently 
                       unable to be
  254 00000102         ; debugged or re-programmed.
  255 00000102         
  256 00000102         ; These are the configuration registers which should not
                        be touched
  257 00000102         ; Port Base addresses for the legacy (not high-performan
                       ce) interface to I/O ports
  258 00000102 40004000 
                       GPIO_PORTA
                               EQU              0x40004000
  259 00000102 40005000 
                       GPIO_PORTB
                               EQU              0x40005000
  260 00000102 40006000 
                       GPIO_PORTC
                               EQU              0x40006000
  261 00000102 40007000 
                       GPIO_PORTD
                               EQU              0x40007000
  262 00000102 40024000 
                       GPIO_PORTE
                               EQU              0x40024000
  263 00000102 40025000 
                       GPIO_PORTF
                               EQU              0x40025000
  264 00000102         
  265 00000102         ; WARNING outputs PD0 & PD1 are shorted to PB6 and PB7 -
                        one pair MUST BE INPUTS!! - we disable D0, D1
  266 00000102         
  267 00000102         ; These are the masks for pins which are outputs, settin
                       g a bit to 1 makes the pin an output, 0 is input
  268 00000102 000000FC 



ARM Macro Assembler    Page 10 


                       PORT_A_MASK
                               EQU              0xfc        ; PA7,6,5,4,3,2 are
                                                             outputs for 7-segm
                                                            ent LEDs
  269 00000102 000000FD 
                       PORT_B_MASK
                               EQU              0xfd        ; PB7,6,5,4,3,2,0 a
                                                            re LEDs
  270 00000102 00000030 
                       PORT_C_MASK
                               EQU              0x30        ; this breaks progr
                                                            amming the CPU - DO
                                                             NOT ENABLE 
  271 00000102 000000CC 
                       PORT_D_MASK
                               EQU              0xcc        ; PD7,6,3,2  Disabl
                                                            e D0, D1 due to sho
                                                            rt with B6, B7
  272 00000102 00000037 
                       PORT_E_MASK
                               EQU              0x37        ; PE0,1,2,4,5 are u
                                                            sed for 7-segment, 
                                                            LED & speaker
  273 00000102 0000000E 
                       PORT_F_MASK
                               EQU              0x0e        ; PF has LEDs on PF
                                                            1,2,3 and buttons P
                                                            F0, PF4 (don't enab
                                                            le buttons as outpu
                                                            ts)
  274 00000102         
  275 00000102         
  276 00000102         ; Offsets are from table 10-6 on page 660
  277 00000102 00000000 
                       GPIO_DATA_OFFSET
                               EQU              0x000       ; Data address is t
                                                            he base address - Y
                                                            OU HAVE TO ADD AN A
                                                            DDRESS MASK TOO to 
                                                            read or write this!
                                                            !
  278 00000102 00000400 
                       GPIO_DIR_OFFSET
                               EQU              0x400       ; Direction registe
                                                            r
  279 00000102 00000420 
                       GPIO_AFSEL_OFFSET
                               EQU              0x420       ; Alternate Functio
                                                            n SELection
  280 00000102 00000510 
                       GPIO_PUR_OFFSET
                               EQU              0x510       ; Pull Up Resistors
                                                            
  281 00000102 0000051C 
                       GPIO_DEN_OFFSET
                               EQU              0x51C       ; Digital ENable
  282 00000102 00000520 
                       GPIO_LOCK_OFFSET
                               EQU              0x520



ARM Macro Assembler    Page 11 


  283 00000102 00000524 
                       GPIO_CR_OFFSET
                               EQU              0x524
  284 00000102 00000528 
                       GPIO_AMSEL_OFFSET
                               EQU              0x528       ; Analog Mode SELec
                                                            t
  285 00000102 0000052C 
                       GPIO_PCTL_OFFSET
                               EQU              0x52C
  286 00000102         
  287 00000102 400FE06C 
                       SYSCTL_HBCTL
                               EQU              0x400FE06C  ; high performance 
                                                            bus control for por
                                                            ts A to F
  288 00000102         
  289 00000102 4C4F434B 
                       GPIO_LOCK_KEY
                               EQU              0x4C4F434B  ; Unlocks the GPIO_
                                                            CR register
  290 00000102 400FE608 
                       SYSCTL_RCGCGPIO_R
                               EQU              0x400FE608  ; Register to enabl
                                                            e clocks to the I/O
                                                             port hardware
  291 00000102         
  292 00000102         ;------------Port_Init------------
  293 00000102         ; Initialize GPIO Port F for negative logic switches on 
                       PF0 and
  294 00000102         ; PF4 as the Launchpad is wired.  Weak internal pull-up
  295 00000102         ; resistors are enabled, and the NMI functionality on PF
                       0 is
  296 00000102         ; disabled.  Make the RGB LED's pins outputs.
  297 00000102         ; Input: none
  298 00000102         ; Output: none
  299 00000102         ; Modifies: R0, R1, R2, R3
  300 00000102         Port_Init
  301 00000102 B500            STMFD            R13!,{R14}  ; push the LR or re
                                                            turn address
  302 00000104         
  303 00000104         ; First enable the clock to the I/O ports, by default th
                       e clocks are off to save power
  304 00000104         ; If a clock is not enabled to a port and you access it 
                       - then the processor hard faults
  305 00000104 4945            LDR              R1, =SYSCTL_RCGCGPIO_R ; activa
                                                            te clock for Ports 
                                                            (see page 340)
  306 00000106 6808            LDR              R0, [R1]
  307 00000108 F040 003F       ORR              R0, R0, #0x3F ; turn on clock t
                                                            o all 6 ports (A to
                                                             F, bits 0 to 5)
  308 0000010C 6008            STR              R0, [R1]
  309 0000010E BF00            NOP
  310 00000110 BF00            NOP                          ; allow time for cl
                                                            ock to finish
  311 00000112         
  312 00000112         ; Set all ports to APB bus instead of AHB - this should 
                       be unnecessary



ARM Macro Assembler    Page 12 


  313 00000112         ; LDR R1, =SYSCTL_HBCTL
  314 00000112         ; LDR R0, [R1]
  315 00000112         ; AND R0, #0xFFFFFFE0  ; set Ports A thru F to APB (0) a
                       nd leave the rest at their default
  316 00000112         ; STR R0, [R1]
  317 00000112         
  318 00000112         ; Page 650, Table 10-1 GPIO Pins with Special Considerat
                       ions.
  319 00000112         ; These pins must be left as configured after reset:
  320 00000112         ;  PA[5:0] (UART0 and SSIO), PB[3:2] (I2C), PC[3:0] (JTA
                       G)
  321 00000112         
  322 00000112         ; Initialize the I/O ports A, B, E, F via a common subro
                       utine Port_Init_Individual
  323 00000112         ; Call Port_Init_Individual with the following paramater
                       s passed:
  324 00000112         ; R1 is the base port address
  325 00000112         ; R2 is the output pin mask (which bits are outputs)
  326 00000112         ; R3 is the input pin mask  (which bits get configured a
                       s inputs)
  327 00000112         
  328 00000112 F04F 0300       MOV              R3, #0x00   ; Select no pins as
                                                             input (unless it's
                                                             changed as for por
                                                            t F)
  329 00000116         
  330 00000116         ; Init Port A, B, E are by default GPIO - set all output
                        pins used to a 1 to enable them
  331 00000116         ;   and leave all of the other pins as previously config
                       ured!
  332 00000116 F04F 2140       LDR              R1, =GPIO_PORTA
  333 0000011A F04F 02FC       MOV              R2, #PORT_A_MASK ; enable commi
                                                            t for Port, 1 means
                                                             allow access
  334 0000011E F000 F81A       BL               Port_Init_Individual
  335 00000122         
  336 00000122         ; Init Port B
  337 00000122 493F            LDR              R1, =GPIO_PORTB
  338 00000124 F04F 02FD       MOV              R2, #PORT_B_MASK ; enable commi
                                                            t for Port, 1 means
                                                             allow access
  339 00000128 F000 F815       BL               Port_Init_Individual
  340 0000012C         
  341 0000012C         ; Init Port C
  342 0000012C 493D            LDR              R1, =GPIO_PORTC
  343 0000012E F04F 0230       MOV              R2, #PORT_C_MASK
  344 00000132         ;BL Port_Init_Individual  ; Do not initialize Port C as 
                       it renders the Tiva board unprogramable !
  345 00000132         
  346 00000132         ; Init Port D
  347 00000132 493D            LDR              R1, =GPIO_PORTD
  348 00000134 F04F 02CC       MOV              R2, #PORT_D_MASK
  349 00000138 F000 F80D       BL               Port_Init_Individual
  350 0000013C         
  351 0000013C         ; Init Port E
  352 0000013C 493B            LDR              R1, =GPIO_PORTE
  353 0000013E F04F 0237       MOV              R2, #PORT_E_MASK ; enable commi
                                                            t for Port, 1 means
                                                             allow access



ARM Macro Assembler    Page 13 


  354 00000142 F000 F808       BL               Port_Init_Individual
  355 00000146         
  356 00000146         ; Init Port F
  357 00000146 493A            LDR              R1, =GPIO_PORTF
  358 00000148 F04F 020E       MOV              R2, #PORT_F_MASK ; enable commi
                                                            t for Port, 1 means
                                                             allow access
  359 0000014C F04F 0311       MOV              R3, #0x11   ; enable weak pull-
                                                            up on PF0 and PF4 (
                                                            buttons)
  360 00000150 F000 F801       BL               Port_Init_Individual
  361 00000154         
  362 00000154 BD00            LDMFD            R13!,{R15}  ; pull the LR or re
                                                            turn address from t
                                                            he stack and return
                                                            
  363 00000156         
  364 00000156         
  365 00000156         ;------------Port_Init_Individual------------
  366 00000156         ; Initialize one GPIO Port with select bits as inputs an
                       d outputs
  367 00000156         ; Output: none
  368 00000156         ; Input: R1, R2, R3
  369 00000156         ; R1 has to be the port address
  370 00000156         ; R2 has to hold the mask for output pins
  371 00000156         ; R3 has to be the mask for input pins
  372 00000156         ; Modifies: R0
  373 00000156         
  374 00000156         Port_Init_Individual
  375 00000156 B500            STMFD            R13!,{R14}  ; push the LR or re
                                                            turn address
  376 00000158 4836            LDR              R0, =0x4C4F434B ; unlock GPIO P
                                                            ort F Commit Regist
                                                            er
  377 0000015A F8C1 0520       STR              R0, [R1, #GPIO_LOCK_OFFSET] ; 2
                                                            ) unlock the lock r
                                                            egister
  378 0000015E EA42 0003       ORR              R0, R2, R3  ; all access to inp
                                                            uts and outputs as 
                                                            masked in R2 and R3
                                                            
  379 00000162 F8C1 0524       STR              R0, [R1, #GPIO_CR_OFFSET] ; ena
                                                            ble commit for Port
                                                             F
  380 00000166 F04F 0000       MOV              R0, #0      ; 0 means analog is
                                                             off
  381 0000016A F8C1 0528       STR              R0, [R1, #GPIO_AMSEL_OFFSET] ; 
                                                            3) disable analog f
                                                            unctionality
  382 0000016E F04F 0000       MOV              R0, #0x00000000 ; 0 means confi
                                                            gure Port F as GPIO
                                                            
  383 00000172 F8C1 052C       STR              R0, [R1, #GPIO_PCTL_OFFSET] ; 4
                                                            ) configure as GPIO
                                                            
  384 00000176 F8D1 0400       LDR              R0, [R1, #GPIO_DIR_OFFSET] ; 5)
                                                             read default direc
                                                            tion register confi
                                                            guration



ARM Macro Assembler    Page 14 


  385 0000017A EA40 0002       ORR              R0, R2      ; ORR in only the b
                                                            its we want as outp
                                                            uts
  386 0000017E F8C1 0400       STR              R0, [R1, #GPIO_DIR_OFFSET] ; 5)
                                                             set direction regi
                                                            ster
  387 00000182 F04F 0000       MOV              R0, #0      ; 0 means disable a
                                                            lternate function 
  388 00000186 F8C1 0420       STR              R0, [R1, #GPIO_AFSEL_OFFSET] ; 
                                                            6) regular port fun
                                                            ction
  389 0000018A F8C1 3510       STR              R3, [R1, #GPIO_PUR_OFFSET] ; pu
                                                            ll-up resistors for
                                                             PF4,PF0
  390 0000018E F04F 00FF       MOV              R0, #0xFF   ; 1 means enable di
                                                            gital I/O
  391 00000192 F8C1 051C       STR              R0, [R1, #GPIO_DEN_OFFSET]
  392 00000196 BD00            LDMFD            R13!,{R15}  ; pull the LR or re
                                                            turn address and re
                                                            turn
  393 00000198         
  394 00000198         ; Beep the speaker on the ECE Shield using port E4 and E
                       5
  395 00000198         ; The speaker is conencted to two pins - toggle each end
                        for more volume than a singled ended drive
  396 00000198         ;
  397 00000198         ; Before exiting ensure that both wires to the speaker a
                       re 0 to prevent it from being heated up
  398 00000198         ;
  399 00000198         ; Each beep, sounded or not, is about the same length - 
                       0x300 loops of delay loop
  400 00000198         ;
  401 00000198         ; Input: R1 sets the tone - 0 is NO BEEP,
  402 00000198         ;                           1 is a high pitch beep and l
                       arger numbers are lower pitched
  403 00000198         ; Output: none
  404 00000198         
  405 00000198 00000300 
                       SpeakerBeepLength
                               EQU              0x300       ; the length of the
                                                             speaker beep
  406 00000198         
  407 00000198         SpeakerBeep
  408 00000198 E92D 481E       STMFD            R13!,{R1-R4, R11, R14} ; push t
                                                            he LR or return add
                                                            ress
  409 0000019C         
  410 0000019C F04F 0430       MOV              R4, #0x30   ; This xor'd with t
                                                            he port holding the
                                                             speaker pins will 
                                                            create a beep
  411 000001A0 F091 0F00       TEQ              R1, #0      ; If R1 = 0 then ju
                                                            st delay but do not
                                                             beep
  412 000001A4 D103            BNE              make_a_sound
  413 000001A6 F04F 0101       MOV              R1, #1      ; stick a valid val
                                                            ue into R1 as 0 wil
                                                            l divide by 0
  414 000001AA F04F 0400       MOV              R4, #0x0    ; setting R4 to 0 w



ARM Macro Assembler    Page 15 


                                                            ill ensure that no 
                                                            beep will sound
  415 000001AE         make_a_sound
  416 000001AE F44F 7340       MOV              R3, #SpeakerBeepLength ; how ma
                                                            ny loops of the bee
                                                            p delay do we do?  
                                                            Ie how long is the 
                                                            beep
  417 000001B2 FBB3 F3F1       UDIV             R3, R1      ; loop the tone R1 
                                                            / R3 times to ensur
                                                            e a total of 0x100 
                                                            delays for all tone
                                                            s
  418 000001B6         
  419 000001B6 4A20            LDR              R2, =GPIO_PORTE + (PORT_E_MASK 
<< 2)
  420 000001B8 F8D2 B000       LDR              R11, [R2, #GPIO_DATA_OFFSET] ; 
                                                            get the initial val
                                                            ue - read-modify-wr
                                                            ite to only change 
                                                            2 bits
  421 000001BC F00B 0BCF       AND              R11, #0xcf  ; clear two bits th
                                                            at the speaker is o
                                                            n
  422 000001C0 F04B 0B10       ORR              R11, #0x10  ; initial speaker o
                                                            utput (one side hig
                                                            h 0x10, the other l
                                                            ow 0x20)
  423 000001C4         buzz_loop
  424 000001C4 F7FF FF60       BL               ShortDelay  ; delay
  425 000001C8 EA8B 0B04       EOR              R11, R4     ; xor to toggle the
                                                             two speaker pins t
                                                            o create a beep
  426 000001CC F8C2 B000       STR              R11, [R2, #GPIO_DATA_OFFSET]
  427 000001D0 3B01            SUBS             R3, #1
  428 000001D2 D1F7            BNE              buzz_loop
  429 000001D4         ; now power down the speaker
  430 000001D4 F8D2 B000       LDR              R11, [R2, #GPIO_DATA_OFFSET] ; 
                                                            restore the speaker
                                                             pins to 0V on each
                                                             side
  431 000001D8 F00B 0BCF       AND              R11, #0xcf  ; clear two bits th
                                                            at the speaker is o
                                                            n
  432 000001DC F8C2 B000       STR              R11, [R2, #GPIO_DATA_OFFSET]
  433 000001E0         
  434 000001E0 E8BD 881E       LDMFD            R13!,{R1-R4, R11, R15} ; pull t
                                                            he LR or return add
                                                            ress and return
  435 000001E4         
  436 000001E4         
  437 000001E4                 ALIGN
  438 000001E4         
  439 000001E4         Port_Table
  440 000001E4 400043F0        DCD              GPIO_PORTA + (PORT_A_MASK << 2)
 
                                                            ; DCD - Define Cons
                                                            tant Double Word (3
                                                            2-bits)



ARM Macro Assembler    Page 16 


  441 000001E8 400053F4 
              400060C0         DCD              GPIO_PORTB + (PORT_B_MASK << 2)
, GPIO_PORTC + (PORT_C_MASK << 2)
  442 000001F0 40007330 
              400240DC         DCD              GPIO_PORTD + (PORT_D_MASK << 2)
, GPIO_PORTE + (PORT_E_MASK << 2)
  443 000001F8 40025038 
              00000000         DCD              GPIO_PORTF + (PORT_F_MASK << 2)
, 0
  444 00000200         
  445 00000200                 ALIGN                        ; make sure the end
                                                             of this section is
                                                             aligned
  446 00000200                 END                          ; end of file - not
                                                            hing after this is 
                                                            assembled
              400253FC 
              400053F4 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              400FE608 
              40005000 
              40006000 
              40007000 
              40024000 
              40025000 
              4C4F434B 
              400240DC 
Command Line: --debug --xref --diag_suppress=9931 --cpu=Cortex-M4.fp --apcs=int
erwork --depend=.\objects\lab3_tiva_template.d -o.\objects\lab3_tiva_template.o
 -I.\RTE\_Target_1 -IC:\Users\navey\AppData\Local\Arm\Packs\Keil\TM4C_DFP\1.1.0
\Device\Include\TM4C123 -IC:\Keil_v5\ARM\CMSIS\Include --predefine="__EVAL SETA
 1" --predefine="__UVISION_VERSION SETA 528" --predefine="TM4C123GH6PM SETA 1" 
--list=.\listings\lab3_tiva_template.lst lab3_tiva_template.s



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

.text 00000000

Symbol: .text
   Definitions
      At line 11 in file lab3_tiva_template.s
   Uses
      None
Comment: .text unused
Bitshift 00000044

Symbol: Bitshift
   Definitions
      At line 66 in file lab3_tiva_template.s
   Uses
      At line 74 in file lab3_tiva_template.s
      At line 93 in file lab3_tiva_template.s

Delay 00000088

Symbol: Delay
   Definitions
      At line 121 in file lab3_tiva_template.s
   Uses
      At line 72 in file lab3_tiva_template.s
      At line 77 in file lab3_tiva_template.s

Display 000000AC

Symbol: Display
   Definitions
      At line 147 in file lab3_tiva_template.s
   Uses
      At line 71 in file lab3_tiva_template.s
Comment: Display used once
Displayloop 000000AE

Symbol: Displayloop
   Definitions
      At line 149 in file lab3_tiva_template.s
   Uses
      None
Comment: Displayloop unused
POLLING 0000006C

Symbol: POLLING
   Definitions
      At line 83 in file lab3_tiva_template.s
   Uses
      At line 94 in file lab3_tiva_template.s
Comment: POLLING used once
POLLING_LOOP 0000006A

Symbol: POLLING_LOOP
   Definitions
      At line 80 in file lab3_tiva_template.s
   Uses
      At line 64 in file lab3_tiva_template.s
Comment: POLLING_LOOP used once
Port_Init 00000102



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Relocatable symbols


Symbol: Port_Init
   Definitions
      At line 300 in file lab3_tiva_template.s
   Uses
      At line 24 in file lab3_tiva_template.s
Comment: Port_Init used once
Port_Init_Individual 00000156

Symbol: Port_Init_Individual
   Definitions
      At line 374 in file lab3_tiva_template.s
   Uses
      At line 334 in file lab3_tiva_template.s
      At line 339 in file lab3_tiva_template.s
      At line 349 in file lab3_tiva_template.s
      At line 354 in file lab3_tiva_template.s
      At line 360 in file lab3_tiva_template.s

Port_Table 000001E4

Symbol: Port_Table
   Definitions
      At line 439 in file lab3_tiva_template.s
   Uses
      None
Comment: Port_Table unused
RandomMap 0000009E

Symbol: RandomMap
   Definitions
      At line 139 in file lab3_tiva_template.s
   Uses
      At line 48 in file lab3_tiva_template.s
Comment: RandomMap used once
RandomNum 000000C2

Symbol: RandomNum
   Definitions
      At line 189 in file lab3_tiva_template.s
   Uses
      At line 46 in file lab3_tiva_template.s
Comment: RandomNum used once
ShortDelay 00000088

Symbol: ShortDelay
   Definitions
      At line 122 in file lab3_tiva_template.s
   Uses
      At line 49 in file lab3_tiva_template.s
      At line 84 in file lab3_tiva_template.s
      At line 424 in file lab3_tiva_template.s

SpeakerBeep 00000198

Symbol: SpeakerBeep
   Definitions
      At line 407 in file lab3_tiva_template.s
   Uses



ARM Macro Assembler    Page 3 Alphabetic symbol ordering
Relocatable symbols

      None
Comment: SpeakerBeep unused
Start 00000000

Symbol: Start
   Definitions
      At line 23 in file lab3_tiva_template.s
   Uses
      At line 13 in file lab3_tiva_template.s
      At line 78 in file lab3_tiva_template.s

buzz_loop 000001C4

Symbol: buzz_loop
   Definitions
      At line 423 in file lab3_tiva_template.s
   Uses
      At line 428 in file lab3_tiva_template.s
Comment: buzz_loop used once
delay_loop 00000092

Symbol: delay_loop
   Definitions
      At line 129 in file lab3_tiva_template.s
   Uses
      At line 131 in file lab3_tiva_template.s
Comment: delay_loop used once
delay_outer_loop 0000008A

Symbol: delay_outer_loop
   Definitions
      At line 125 in file lab3_tiva_template.s
   Uses
      At line 134 in file lab3_tiva_template.s
Comment: delay_outer_loop used once
exitDelay 0000009C

Symbol: exitDelay
   Definitions
      At line 136 in file lab3_tiva_template.s
   Uses
      At line 133 in file lab3_tiva_template.s
Comment: exitDelay used once
make_a_sound 000001AE

Symbol: make_a_sound
   Definitions
      At line 415 in file lab3_tiva_template.s
   Uses
      At line 412 in file lab3_tiva_template.s
Comment: make_a_sound used once
20 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Absolute symbols

BLUE 00000004

Symbol: BLUE
   Definitions
      At line 18 in file lab3_tiva_template.s
   Uses
      None
Comment: BLUE unused
CONSTANT 00004E20

Symbol: CONSTANT
   Definitions
      At line 140 in file lab3_tiva_template.s
   Uses
      At line 143 in file lab3_tiva_template.s
Comment: CONSTANT used once
GPIO_AFSEL_OFFSET 00000420

Symbol: GPIO_AFSEL_OFFSET
   Definitions
      At line 279 in file lab3_tiva_template.s
   Uses
      At line 388 in file lab3_tiva_template.s
Comment: GPIO_AFSEL_OFFSET used once
GPIO_AMSEL_OFFSET 00000528

Symbol: GPIO_AMSEL_OFFSET
   Definitions
      At line 284 in file lab3_tiva_template.s
   Uses
      At line 381 in file lab3_tiva_template.s
Comment: GPIO_AMSEL_OFFSET used once
GPIO_CR_OFFSET 00000524

Symbol: GPIO_CR_OFFSET
   Definitions
      At line 283 in file lab3_tiva_template.s
   Uses
      At line 379 in file lab3_tiva_template.s
Comment: GPIO_CR_OFFSET used once
GPIO_DATA_OFFSET 00000000

Symbol: GPIO_DATA_OFFSET
   Definitions
      At line 277 in file lab3_tiva_template.s
   Uses
      At line 37 in file lab3_tiva_template.s
      At line 41 in file lab3_tiva_template.s
      At line 43 in file lab3_tiva_template.s
      At line 56 in file lab3_tiva_template.s
      At line 59 in file lab3_tiva_template.s
      At line 89 in file lab3_tiva_template.s
      At line 154 in file lab3_tiva_template.s
      At line 158 in file lab3_tiva_template.s
      At line 161 in file lab3_tiva_template.s
      At line 420 in file lab3_tiva_template.s
      At line 426 in file lab3_tiva_template.s
      At line 430 in file lab3_tiva_template.s
      At line 432 in file lab3_tiva_template.s



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Absolute symbols


GPIO_DEN_OFFSET 0000051C

Symbol: GPIO_DEN_OFFSET
   Definitions
      At line 281 in file lab3_tiva_template.s
   Uses
      At line 391 in file lab3_tiva_template.s
Comment: GPIO_DEN_OFFSET used once
GPIO_DIR_OFFSET 00000400

Symbol: GPIO_DIR_OFFSET
   Definitions
      At line 278 in file lab3_tiva_template.s
   Uses
      At line 384 in file lab3_tiva_template.s
      At line 386 in file lab3_tiva_template.s

GPIO_LOCK_KEY 4C4F434B

Symbol: GPIO_LOCK_KEY
   Definitions
      At line 289 in file lab3_tiva_template.s
   Uses
      None
Comment: GPIO_LOCK_KEY unused
GPIO_LOCK_OFFSET 00000520

Symbol: GPIO_LOCK_OFFSET
   Definitions
      At line 282 in file lab3_tiva_template.s
   Uses
      At line 377 in file lab3_tiva_template.s
Comment: GPIO_LOCK_OFFSET used once
GPIO_PCTL_OFFSET 0000052C

Symbol: GPIO_PCTL_OFFSET
   Definitions
      At line 285 in file lab3_tiva_template.s
   Uses
      At line 383 in file lab3_tiva_template.s
Comment: GPIO_PCTL_OFFSET used once
GPIO_PORTA 40004000

Symbol: GPIO_PORTA
   Definitions
      At line 258 in file lab3_tiva_template.s
   Uses
      At line 332 in file lab3_tiva_template.s
      At line 440 in file lab3_tiva_template.s

GPIO_PORTB 40005000

Symbol: GPIO_PORTB
   Definitions
      At line 259 in file lab3_tiva_template.s
   Uses
      At line 35 in file lab3_tiva_template.s
      At line 153 in file lab3_tiva_template.s



ARM Macro Assembler    Page 3 Alphabetic symbol ordering
Absolute symbols

      At line 337 in file lab3_tiva_template.s
      At line 441 in file lab3_tiva_template.s

GPIO_PORTC 40006000

Symbol: GPIO_PORTC
   Definitions
      At line 260 in file lab3_tiva_template.s
   Uses
      At line 342 in file lab3_tiva_template.s
      At line 441 in file lab3_tiva_template.s

GPIO_PORTD 40007000

Symbol: GPIO_PORTD
   Definitions
      At line 261 in file lab3_tiva_template.s
   Uses
      At line 347 in file lab3_tiva_template.s
      At line 442 in file lab3_tiva_template.s

GPIO_PORTE 40024000

Symbol: GPIO_PORTE
   Definitions
      At line 262 in file lab3_tiva_template.s
   Uses
      At line 40 in file lab3_tiva_template.s
      At line 55 in file lab3_tiva_template.s
      At line 157 in file lab3_tiva_template.s
      At line 352 in file lab3_tiva_template.s
      At line 419 in file lab3_tiva_template.s
      At line 442 in file lab3_tiva_template.s

GPIO_PORTF 40025000

Symbol: GPIO_PORTF
   Definitions
      At line 263 in file lab3_tiva_template.s
   Uses
      At line 357 in file lab3_tiva_template.s
      At line 443 in file lab3_tiva_template.s

GPIO_PORTF_AFSEL_R 40025420

Symbol: GPIO_PORTF_AFSEL_R
   Definitions
      At line 216 in file lab3_tiva_template.s
   Uses
      None
Comment: GPIO_PORTF_AFSEL_R unused
GPIO_PORTF_AMSEL_R 40025528

Symbol: GPIO_PORTF_AMSEL_R
   Definitions
      At line 221 in file lab3_tiva_template.s
   Uses
      None
Comment: GPIO_PORTF_AMSEL_R unused



ARM Macro Assembler    Page 4 Alphabetic symbol ordering
Absolute symbols

GPIO_PORTF_CR_R 40025524

Symbol: GPIO_PORTF_CR_R
   Definitions
      At line 220 in file lab3_tiva_template.s
   Uses
      None
Comment: GPIO_PORTF_CR_R unused
GPIO_PORTF_DATA_R 400253FC

Symbol: GPIO_PORTF_DATA_R
   Definitions
      At line 215 in file lab3_tiva_template.s
   Uses
      At line 25 in file lab3_tiva_template.s
      At line 88 in file lab3_tiva_template.s

GPIO_PORTF_DEN_R 4002551C

Symbol: GPIO_PORTF_DEN_R
   Definitions
      At line 218 in file lab3_tiva_template.s
   Uses
      None
Comment: GPIO_PORTF_DEN_R unused
GPIO_PORTF_DIR_R 40025400

Symbol: GPIO_PORTF_DIR_R
   Definitions
      At line 214 in file lab3_tiva_template.s
   Uses
      None
Comment: GPIO_PORTF_DIR_R unused
GPIO_PORTF_LOCK_R 40025520

Symbol: GPIO_PORTF_LOCK_R
   Definitions
      At line 219 in file lab3_tiva_template.s
   Uses
      None
Comment: GPIO_PORTF_LOCK_R unused
GPIO_PORTF_PCTL_R 4002552C

Symbol: GPIO_PORTF_PCTL_R
   Definitions
      At line 222 in file lab3_tiva_template.s
   Uses
      None
Comment: GPIO_PORTF_PCTL_R unused
GPIO_PORTF_PUR_R 40025510

Symbol: GPIO_PORTF_PUR_R
   Definitions
      At line 217 in file lab3_tiva_template.s
   Uses
      None
Comment: GPIO_PORTF_PUR_R unused
GPIO_PUR_OFFSET 00000510




ARM Macro Assembler    Page 5 Alphabetic symbol ordering
Absolute symbols

Symbol: GPIO_PUR_OFFSET
   Definitions
      At line 280 in file lab3_tiva_template.s
   Uses
      At line 389 in file lab3_tiva_template.s
Comment: GPIO_PUR_OFFSET used once
GREEN 00000008

Symbol: GREEN
   Definitions
      At line 19 in file lab3_tiva_template.s
   Uses
      None
Comment: GREEN unused
PORT_A_MASK 000000FC

Symbol: PORT_A_MASK
   Definitions
      At line 268 in file lab3_tiva_template.s
   Uses
      At line 333 in file lab3_tiva_template.s
      At line 440 in file lab3_tiva_template.s

PORT_B_MASK 000000FD

Symbol: PORT_B_MASK
   Definitions
      At line 269 in file lab3_tiva_template.s
   Uses
      At line 35 in file lab3_tiva_template.s
      At line 153 in file lab3_tiva_template.s
      At line 338 in file lab3_tiva_template.s
      At line 441 in file lab3_tiva_template.s

PORT_C_MASK 00000030

Symbol: PORT_C_MASK
   Definitions
      At line 270 in file lab3_tiva_template.s
   Uses
      At line 343 in file lab3_tiva_template.s
      At line 441 in file lab3_tiva_template.s

PORT_D_MASK 000000CC

Symbol: PORT_D_MASK
   Definitions
      At line 271 in file lab3_tiva_template.s
   Uses
      At line 348 in file lab3_tiva_template.s
      At line 442 in file lab3_tiva_template.s

PORT_E_MASK 00000037

Symbol: PORT_E_MASK
   Definitions
      At line 272 in file lab3_tiva_template.s
   Uses
      At line 40 in file lab3_tiva_template.s



ARM Macro Assembler    Page 6 Alphabetic symbol ordering
Absolute symbols

      At line 55 in file lab3_tiva_template.s
      At line 157 in file lab3_tiva_template.s
      At line 353 in file lab3_tiva_template.s
      At line 419 in file lab3_tiva_template.s
      At line 442 in file lab3_tiva_template.s

PORT_F_MASK 0000000E

Symbol: PORT_F_MASK
   Definitions
      At line 273 in file lab3_tiva_template.s
   Uses
      At line 358 in file lab3_tiva_template.s
      At line 443 in file lab3_tiva_template.s

RED 00000002

Symbol: RED
   Definitions
      At line 17 in file lab3_tiva_template.s
   Uses
      None
Comment: RED unused
SHORTDELAYCOUNT 00000226

Symbol: SHORTDELAYCOUNT
   Definitions
      At line 118 in file lab3_tiva_template.s
   Uses
      At line 127 in file lab3_tiva_template.s
Comment: SHORTDELAYCOUNT used once
SW1 00000010

Symbol: SW1
   Definitions
      At line 20 in file lab3_tiva_template.s
   Uses
      At line 87 in file lab3_tiva_template.s
Comment: SW1 used once
SW2 00000001

Symbol: SW2
   Definitions
      At line 21 in file lab3_tiva_template.s
   Uses
      None
Comment: SW2 unused
SYSCTL_HBCTL 400FE06C

Symbol: SYSCTL_HBCTL
   Definitions
      At line 287 in file lab3_tiva_template.s
   Uses
      None
Comment: SYSCTL_HBCTL unused
SYSCTL_RCGCGPIO_R 400FE608

Symbol: SYSCTL_RCGCGPIO_R
   Definitions



ARM Macro Assembler    Page 7 Alphabetic symbol ordering
Absolute symbols

      At line 290 in file lab3_tiva_template.s
   Uses
      At line 305 in file lab3_tiva_template.s
Comment: SYSCTL_RCGCGPIO_R used once
SpeakerBeepLength 00000300

Symbol: SpeakerBeepLength
   Definitions
      At line 405 in file lab3_tiva_template.s
   Uses
      At line 416 in file lab3_tiva_template.s
Comment: SpeakerBeepLength used once
41 symbols
397 symbols in table
